<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>recallwolf</title>
  
  
  <link href="/recallwolf.github.io/atom.xml" rel="self"/>
  
  <link href="https://recallwolf.github.io/recallwolf.github.io/"/>
  <updated>2020-03-30T15:40:31.470Z</updated>
  <id>https://recallwolf.github.io/recallwolf.github.io/</id>
  
  <author>
    <name>RecallWolf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>写给自己</title>
    <link href="https://recallwolf.github.io/recallwolf.github.io/2019/03/07/%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1/"/>
    <id>https://recallwolf.github.io/recallwolf.github.io/2019/03/07/写给自己/</id>
    <published>2019-03-07T04:38:44.000Z</published>
    <updated>2020-03-30T15:40:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>已经大概有几天了，说实话这几天挺难受的，失眠是一直在的问题，只不过这几天做噩梦的次数好像增多了，室友经常听到我晚上鬼叫。<br>被人说不行是一个很难受的事，更何况是自己喜欢的事情。我喜欢码代码，从我在朋友圈看到别人展示自己写的网站的时候。想到高中对代码的憧憬，懵懵懂懂的买了的那本落灰的c语言高程。那时我希望我也能自己写一个网站，于是就有了这些后来的事情。<br>不过真实的情况是我可能确实能力不行。所以我也不愿再和家里争吵。这一切的原因都是因为我能力不足！拿不出自己的成果，就要求别人的认可想想都不可能。这段时间我一直在思考我的未来，终究是迷茫的，有人说干工程的人很单纯，屁！有人说人世间的丑陋90%都展示在酒桌上，大概就是如此。（有时候想想如果当初坚持选择计算机，可能现在就没有那么多的屁事。）<br>想了很多，大概我最讨厌听到的话就是“专业对口”“90%不可能干自己满意的工作”“无业游民”之类的，为什么总有那么多人对我的人生指指点点，告诉你所谓的“经验”，这些经验还大多是因为自己当初不愿努力或者又如不敢踏出那一步，而安慰自己的说辞。告诉你所谓世界不是那么如意，要学会接受。总有人会这样说，给自己画个圈圈，告诉你以后这就是你的生活，告诉你到圈圈外很难。凭什么你不敢的事，就代表别人不敢。如果有人继续给我说这些什么人生，世界之类的，果断拉黑。<br>说说自己能力不足的事，这段时间我也一直在思考，能力不足当然就是想办法把自己能力提高上去。或许我是经验不足，又或许我是基础太差。我在想是否要考研，考一个只比国家线高几分的学校，在复习的过程中把计算机的基础梳理一遍。现在我还不能给一个准确的答案。但是我目前唯一知道的是，即便是在任何岗位任何地方，最终我都会回到那个地方。<br>没有人能够让你放弃自己的理想，除了你自己。坚强一点!<br>我希望以后我能大声的对世界说：我做到了！</p>]]></content>
    
    <summary type="html">
    
      大概最大的失望就是自己能力不足
    
    </summary>
    
      <category term="Others" scheme="https://recallwolf.github.io/recallwolf.github.io/categories/Others/"/>
    
    
      <category term="随感" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/%E9%9A%8F%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>JS函数防抖与节流</title>
    <link href="https://recallwolf.github.io/recallwolf.github.io/2019/01/30/js%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>https://recallwolf.github.io/recallwolf.github.io/2019/01/30/js函数防抖与节流/</id>
    <published>2019-01-30T14:23:48.000Z</published>
    <updated>2020-03-30T15:40:31.390Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么要进行函数节流与防抖"><a href="#为什么要进行函数节流与防抖" class="headerlink" title="为什么要进行函数节流与防抖"></a>为什么要进行函数节流与防抖</h3><p>浏览器进行一些有关滚动或者输入框校验之类的事件，如果一直无限制的调用回调函数，会导致浏览器性能的下降，直接降低用户的用户体验。比如：</p><pre><code>function callback() {  console.log(window.scrollY)}window.addEventListener(&apos;scroll&apos;, callback)</code></pre>  <img src="/recallwolf.github.io/2019/01/30/js函数防抖与节流/scroll.png"><p>  可以看到随便滚动一下就调用了那么多次回调函数。</p><h3 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖(debounce)"></a>函数防抖(debounce)</h3><p>函数防抖指的是如果一件事情持续触发，则在该事件停止触发一段时间后才执行回调函数。</p><p>用代码说明：</p><pre><code>function debounce(delay) {  var timeout = undefined  return function() {    if(timeout) {      clearTimeout(timeout)    }    timeout = setTimeout(() =&gt; {      console.log(window.scrollY)    }, delay)  }}window.addEventListener(&apos;scroll&apos;, debounce(1000))</code></pre><p>如果<code>scroll</code>事件一直触发，则一直清除定时器并设置新的1s定时器。事件一旦不触发，定时器则正常执行。</p><h3 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流(throttle)"></a>函数节流(throttle)</h3><p>函数节流指的是如果一件事持续触发，则每隔一个时间段调用一次回调函数。</p><p>函数节流能实现的方式有很多</p><pre><code>function throttle(delay) {  var timer = undefined  return function() {    if (!timer) {      timer = setTimeout(() =&gt; {        console.log(window.scrollY)        timer = undefined      }, delay)    }  }}window.addEventListener(&apos;scroll&apos;, throttle(1000))</code></pre><p>滚动停止时，由于定时器的delay延迟，可能还会执行一次函数。</p><p>时间控制也可以使用时间戳的形式</p><pre><code>function throttle(delay) {  var start = Date.now()  return function() {    var end = Date.now()    if (end - start &gt;= delay) {      console.log(window.scrollY)      start = Date.now()    }  }}window.addEventListener(&apos;scroll&apos;, throttle(1000))</code></pre><p>利用函数闭包，通过时间戳的形式，一般情况下第一次会立即执行(但是如果闭包函数执行和滚动时间相差小于delay则第一次不会执行)。滚动停止之前与最后一次执行回调这一段时间，也不会在触发回调事件。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看出的是函数防抖是维护了一个计时器。只要判断事件是否持续运行。</p><p>而函数节流是判断一个时间段是否达到。可以通过维护时间戳和计时器来实现。</p>]]></content>
    
    <summary type="html">
    
      关于函数防抖与节流的一些认识
    
    </summary>
    
      <category term="JavaScript" scheme="https://recallwolf.github.io/recallwolf.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>发布/订阅模式与观察者模式</title>
    <link href="https://recallwolf.github.io/recallwolf.github.io/2019/01/13/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://recallwolf.github.io/recallwolf.github.io/2019/01/13/发布-订阅模式与观察者模式/</id>
    <published>2019-01-13T12:51:25.000Z</published>
    <updated>2020-03-30T15:40:31.471Z</updated>
    
    <content type="html"><![CDATA[<p>语言模式不是JavaScript私有，在这里用JS来一定程度的实现。</p><h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h3><p>发布订阅模式:订阅者在调度中心注册订阅事件，发布者发布该事件到调度中心</p><p>如图所示</p><img src="/recallwolf.github.io/2019/01/13/发布-订阅模式与观察者模式/pub&sub.png"> <p>基本实现：</p><pre><code>var makePubSub=function(){  var callbacks={},  publish=function(){    //将参数对象转换为真实数组    var args=Array.prototype.slice.call(arguments,0);    console.log(args)    //提取第一项事件名称    var ev=args.shift();    console.log(args)    //如果回调对象不存在则返回    var list,i,l;    if(!callbacks[ev]){      return this;    }    list=callbacks[ev];    //调用回调函数, 传入其余参数    for(i=0,l=list.length;i&lt;l;i++){      list[i].apply(this,args);    }    return this;  },  subscribe=function(ev,callback){    //检查是否ev已注册    //如果不存在则创建数组    if(!callbacks[ev]){      callbacks[ev]=[];    }    callbacks[ev].push(callback);    return this;  };  return {pub:publish,sub:subscribe};}test=makePubSub();test.sub(&quot;alert&quot;,function(data){console.log(data)})test.pub(&quot;alert&quot;,&quot;hello world&quot;);</code></pre><p>可以看出基本的实现是：订阅函数向事件队列推送回调函数，发布函数执行事件队列中的函数。事件队列起到调度中心作用。</p><p>发布订阅者模式中，订阅者是不知道也不关心事件是为什么触发，是由哪一个事件触发，只知道事件触发时候，会告诉自己。发布者也不用一一通知，只要告诉调度中心，事件触发了就好了。所以代码松耦合。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式：目标和观察者是基类，目标提供维护观察者的一系列方法，观察者提供更新接口。在具体目标发生变化时候，调度观察者的更新方法。</p><p>如图所示</p><img src="/recallwolf.github.io/2019/01/13/发布-订阅模式与观察者模式/watcher.png"> <p>基本实现：</p><pre><code>//观察者列表function ObserverList() {  this.observerList = []; }//添加观察者ObserverList.prototype.add = function(obj) {  this.observerList.push(obj);}//获取观察者列表ObserverList.prototype.get = function() {  return this.observerList;}//观察者方法function Observer(callback) {  this.method = callback;}//目标function Subject() {  this.observers = new ObserverList();  this.data = &quot;&quot;;  //改变目标数据,通知观察者  this.setValue = function(val){    this.data = val;    this.notify(val);  };}//添加观察者Subject.prototype.addObsever = function (obs) {  this.observers.add(obs);}//向观察者发送通知Subject.prototype.notify = function (args) {  for(var i = 0; i &lt; this.observers.get().length; i++) {    this.observers.get()[i].method(args);  }}var subject = new Subject();var observer1 = new Observer(function(data) {  console.log(data);});subject.addObsever(observer1);subject.setValue(&quot;helloWorld&quot;);</code></pre><p>基本实现方式是构造了观察者列表，观察者和目标说三个对象，一旦改变了目标就通知所有的观察者。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对比起来<br><img src="/recallwolf.github.io/2019/01/13/发布-订阅模式与观察者模式/all.png"><br>图片来源：<a href="http://developers-club.com/posts/270339/" target="_blank" rel="noopener">developers-club</a></p><p>观察者模式是由具体目标调度的，而发布/订阅模式是统一由调度中心调的，所以观察者模式的订阅者与发布者之间是存在依赖的，而发布/订阅模式则不会。<br>像promise的实现就是发布/订阅者模式，当状态变为fulfilled后，则在事件队列依次执行订阅者的回调函数。Vue中的watcher的实现就是观察者模式。</p>]]></content>
    
    <summary type="html">
    
      发布/订阅模式与观察者模式的实现与不同
    
    </summary>
    
      <category term="JavaScript" scheme="https://recallwolf.github.io/recallwolf.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript]" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS进行数组去重</title>
    <link href="https://recallwolf.github.io/recallwolf.github.io/2019/01/09/js%E8%BF%9B%E8%A1%8C%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <id>https://recallwolf.github.io/recallwolf.github.io/2019/01/09/js进行数组去重/</id>
    <published>2019-01-09T12:55:48.000Z</published>
    <updated>2020-03-30T15:40:31.407Z</updated>
    
    <content type="html"><![CDATA[<p>注：本文<a href="https://zhuanlan.zhihu.com/p/24753549" target="_blank" rel="noopener">转载</a>，  作者：TooBug</p><h2 id="判断相等"><a href="#判断相等" class="headerlink" title="判断相等"></a>判断相等</h2><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>初看NaN时，很容易把它当成和null、undefined一样的独立数据类型。但其实，它是数字类型。</p><pre><code>// numberconsole.log(typeof NaN);</code></pre><p>根据规范，比较运算中只要有一个值为NaN，则比较结果为false，所以会有下面这些看起来略蛋疼的结论：</p><pre><code>// 全都是false0 &lt; NaN;0 &gt; NaN;0 == NaN;0 === NaN;</code></pre><p>以最后一个表达式<code>0 === NaN</code>为例，在规范中有明确规定（<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-strict-equality-comparison" target="_blank" rel="noopener">http://www.ecma-international.org/ecma-262/6.0/#sec-strict-equality-comparison</a>）：</p><blockquote><ol><li>If Type(x) is Number, then<br>a. If x is NaN, return false.<br>b. If y is NaN, return false.<br>c. If x is the same Number value as y, return true.<br>d. If x is +0 and y is −0, return true.<br>e. If x is −0 and y is +0, return true.<br>f. Return false.  </li></ol></blockquote><p>这意味着任何涉及到NaN的情况都不能简单地使用比较运算来判定是否相等。比较科学的方法只能是使用<code>isNaN()</code>：</p><pre><code>var a = NaN;var b = NaN;// trueconsole.log(isNaN(a) &amp;&amp; isNaN(b));</code></pre><h3 id="原始值和包装对象"><a href="#原始值和包装对象" class="headerlink" title="原始值和包装对象"></a>原始值和包装对象</h3><p>如果你研究过<code>&#39;a&#39;.trim()</code>这样的代码的话，不知道是否产生过这样的疑问：’a’明明是一个原始值（字符串），它为什么可以直接调用.trim()方法呢？当然，很可能你已经知道答案：因为JS在执行这样的代码的时候会对原始值做一次包装，让’a’变成一个字符串对象，然后执行这个对象的方法，执行完之后再把这个包装对象脱掉。可以用下面的代码来理解：</p><pre><code>// &apos;a&apos;.trim();var tmp = new String(&apos;a&apos;);tmp.trim();</code></pre><p>这段代码只是辅助我们理解的。但包装对象这个概念在JS中却是真实存在的。</p><pre><code>var a = new String(&apos;a&apos;);var b = &apos;b&apos;;</code></pre><p>a即是一个包装对象，它和b一样，代表一个字符串。它们都可以使用字符串的各种方法（比如<code>trim()</code>），也可以参与字符串运算（+号连接等）。</p><p>但他们有一个关键的区别：类型不同！</p><pre><code>typeof a; // objecttypeof b; // string</code></pre><p>在做字符串比较的时候，类型的不同会导致结果有一些出乎意料：</p><pre><code>var a1 = &apos;a&apos;;var a2 = new String(&apos;a&apos;);var a3 = new String(&apos;a&apos;);a1 == a2; // truea1 == a3; // truea2 == a3; // falsea1 === a2; // falsea1 === a3; // falsea2 === a3; // false</code></pre><p>同样是表示字符串a的变量，在使用严格比较时竟然不是相等的，在直觉上这是一件比较难接受的事情，在各种开发场景下，也非常容易忽略这些细节。</p><h3 id="对象和对象"><a href="#对象和对象" class="headerlink" title="对象和对象"></a>对象和对象</h3><p>在涉及比较的时候，还会碰到对象。具体而言，大致可以分为三种情况：纯对象、实例对象、其它类型的对象。</p><h4 id="纯对象"><a href="#纯对象" class="headerlink" title="纯对象"></a>纯对象</h4><p>纯对象（plain object）具体指什么并不是非常明确，为减少不必要的争议，下文中使用纯对象指代由字面量生成的、成员中不含函数和日期、正则表达式等类型的对象。<br>如果直接拿两个对象进行比较，不管是==还是===，毫无疑问都是不相等的。但是在实际使用时，这样的规则是否一定满足我们的需求？举个例子，我们的应用中有两个配置项：</p><pre><code>// 原来有两个属性// var prop1 = 1;// var prop2 = 2;// 重构代码时两个属性被放到同一个对象中var config = {    prop1: 1,    prop2: 2};</code></pre><p>假设在某些场景下，我们需要比较两次运行的配置项是否相同。在重构前，我们分别比较两次运行的<code>prop1</code>和<code>prop2</code>即可。而在重构后，我们可能需要比较<code>config</code>对象所代表的配置项是否一致。在这样的场景下，直接用<code>==</code>或者<code>===</code>来比较对象，得到的并不是我们期望的结果。</p><p>在这样的场景下，我们可能需要自定义一些方法来处理对象的比较。常见的可能是通过<code>JSON.stringify()</code>对对象进行序列化之后再比较字符串，当然这个过程并非完全可靠，只是一个思路。</p><p>如果你觉得这个场景是无中生有的话，可以再回想一下断言库，同样是基于对象成员，判断结果是否和预期相符。<br>实例对象</p><p>实例对象主要指通过构造函数（类）生成的对象。这样的对象和纯对象一样，直接比较都是不等的，但也会碰到需要判断是否是同一对象的情况。一般而言，因为这种对象有比较复杂的内部结构（甚至有一部分数据在原型上），无法直接从外部比较是否相等。比较靠谱的判断方法是由构造函数（类）来提供静态方法或者实例方法来判断是否相等。</p><h4 id="其它对象"><a href="#其它对象" class="headerlink" title="其它对象"></a>其它对象</h4><p>其它对象主要指数组、日期、正则表达式等这类在Object基础上派生出来的对象。这类对象各有各的特殊性，一般需要根据场景来构造判断方法，决定两个对象是否相等。</p><p>比如，日期对象，可能需要通过<code>Date.prototype.getTime()</code>方法获取时间戳来判断是否表示同一时刻。正则表达式可能需要通过<code>toString()</code>方法获取到原始字面量来判断是否是相同的正则表达式。</p><h4 id="和"><a href="#和" class="headerlink" title="==和==="></a>==和===</h4><p>在一些文章中，看到某一些数组去重的方法，在判断元素是否相等时，使用的是==比较运算符。众所周知，这个运算符在比较前会先查看元素类型，当类型不一致时会做隐式类型转换。这其实是一种非常不严谨的做法。因为无法区分在做隐匿类型转换后值一样的元素，例如0、’’、false、null、undefined等。</p><p>同时，还有可能出现一些只能黑人问号的结果，例如：</p><pre><code>[] == ![]; //true</code></pre><h2 id="去重实现"><a href="#去重实现" class="headerlink" title="去重实现"></a>去重实现</h2><h3 id="双重遍历"><a href="#双重遍历" class="headerlink" title="双重遍历"></a>双重遍历</h3><pre><code>function unique(arr) {  var ret = [];  var len = arr.length;  var isRepeat;  for(var i=0; i&lt;len; i++) {    isRepeat = false;    for(var j=i+1; j&lt;len; j++) {      if(arr[i] === arr[j]){        isRepeat = true;        break;      }    }    if(!isRepeat){      ret.push(arr[i]);    }  }  return ret;}</code></pre><p>或者</p><pre><code>function unique(arr) {  var ret = [];  var len = arr.length;  for(var i=0; i&lt;len; i++){    for(var j=i+1; j&lt;len; j++){      if(arr[i] === arr[j]){        j = ++i;      }    }    ret.push(arr[i]);  }  return ret;}</code></pre><p>大致的思路是第a元素与后面n-a个元素进行比较<br>第一种方式 如果不相等，退出二层循环推入数组直到最后没有相等的元素<br>第二种方式 如果相等则在跳过第一层一次循环（相当于第一层循环直接进下一次），如果第二层循环都不相等则推入数组</p><p>注意的是由于<code>NaN === NaN</code>返回的是false，所以不能使用该表达是判断NaN，否则两种方式仍会有NaN重复<br>可以使用<code>isNaN()</code>添加一层判断</p><h3 id="Array-prototype-indexOf"><a href="#Array-prototype-indexOf" class="headerlink" title="Array.prototype.indexOf()"></a>Array.prototype.indexOf()</h3><p>  <code>Array.prototype.filter</code> 为数组中的每个元素调用一次 <code>callback</code> 函数，并利用所有使得 <code>callback</code> 返回 <code>true</code> 或 等价于 <code>true</code> 的值 的元素创建一个新数组</p><p>  <code>Array.prototype.indexOf</code> 使用<code>strict equality</code>(无论是 ===, 还是 <code>triple-equals</code>操作符都基于同样的方法)进行判断 <code>searchElement</code>与数组中包含的元素之间的关系。</p><pre><code>function unique(arr) {  return arr.filter(function(item, index){    // indexOf返回第一个索引值，    // 如果当前索引不是第一个索引，说明是重复值    return arr.indexOf(item) === index;  });}</code></pre><p>或者</p><pre><code>function unique(arr) {  var ret = [];  arr.forEach(function(item){    if(ret.indexOf(item) === -1){      ret.push(item);    }  });  return ret;}</code></pre><p>第一种是通过判断索引是否是第一个索引来判断重复与否 通过<code>filter</code>函数过滤掉不等于第一个索引的数值</p><p>第二种是通过遍历arr数组的值找出ret数组是否存在相同的值，再判断是否推入ret数组</p><p>通过[规范]（<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.indexof" target="_blank" rel="noopener">http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.indexof</a>），indexOf()使用的是严格比较，也就是===。所以第一种方式NaN都不存在，第二种方式仍存在。</p><blockquote><p>再次强调：按照前文所述，===不能处理NaN的相等性判断。</p></blockquote><h3 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes()"></a>Array.prototype.includes()</h3><p><code>Array.prototype.includes()</code>方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p><pre><code>function unique(arr) {  var ret = [];  arr.forEach(function(item){      if(!ret.includes(item)){          ret.push(item);      }  });  return ret;}</code></pre><h3 id="使用对象key来去重"><a href="#使用对象key来去重" class="headerlink" title="使用对象key来去重"></a>使用对象key来去重</h3><p>由于对象的key不可重复性</p><pre><code>function unique(arr) {  var ret = [];  var len = arr.length;  var tmp = {};  for(var i=0; i&lt;len; i++){    if(!tmp[arr[i]]){        tmp[arr[i]] = 1;        ret.push(arr[i]);    }  }  return ret;}</code></pre><p>但由于对象key只能为字符串，因此这种去重方法有许多局限性：</p><ol><li><p>无法区分隐式类型转换成字符串后一样的值，比如1和’1’</p></li><li><p>无法处理复杂数据类型，比如对象（因为对象作为key会变成[object Object]）</p></li><li><p>特殊数据，比如<code>__proto__</code>会挂掉，因为tmp对象的<code>__proto__</code>属性无法被重写</p></li></ol><p>对于第一点和第三点，有人提出可以为对象的key增加一个类型，或者将类型放到对象的value中来解决：</p><pre><code>function unique(arr) {    var ret = [];    var len = arr.length;    var tmp = {};    var tmpKey;    for(var i=0; i&lt;len; i++){        tmpKey = typeof arr[i] + arr[i];        if(!tmp[tmpKey]){            tmp[tmpKey] = 1;            ret.push(arr[i]);        }    }    return ret;}</code></pre><p>而第二个问题，如果像上文所说，在允许对对象进行自定义的比较规则，也可以将对象序列化之后作为key来使用。这里为简单起见，使用JSON.stringify()进行序列化。</p><pre><code>function unique(arr) {  var ret = [];  var len = arr.length;  var tmp = {};  var tmpKey;  for(var i=0; i&lt;len; i++){      tmpKey = typeof arr[i] + JSON.stringify(arr[i]);      if(!tmp[tmpKey]){          tmp[tmpKey] = 1;          ret.push(arr[i]);      }  }  return ret;}</code></pre><p>但是这样会导致正则表达式消失序列化之后为{}</p><h3 id="Map-Key"><a href="#Map-Key" class="headerlink" title="Map Key"></a>Map Key</h3><p>可以看到，使用对象key来处理数组去重的问题，其实是一件比较麻烦的事情，处理不好很容易导致结果不正确。而这些问题的根本原因就是因为key在使用时有限制。</p><p>那么，能不能有一种key使用没有限制的对象呢？答案是——真的有！那就是ES2015中的Map。</p><blockquote><p>Map是一种新的数据类型，可以把它想象成key类型没有限制的对象。此外，它的存取使用单独的get()、set()接口。</p></blockquote><pre><code>var tmp = new Map();tmp.set(1, 1);tmp.get(1); // 1tmp.set(&apos;2&apos;, 2);tmp.get(&apos;2&apos;); // 2tmp.set(true, 3);tmp.get(true); // 3tmp.set(undefined, 4);tmp.get(undefined); // 4tmp.set(NaN, 5);tmp.get(NaN); // 5var arr = [], obj = {};tmp.set(arr, 6);tmp.get(arr); // 6tmp.set(obj, 7);tmp.get(obj); // 7</code></pre><p>由于Map使用单独的接口来存取数据，所以不用担心key会和内置属性重名（如上文提到的<code>__proto__</code>）。使用Map改写一下我们的去重方法：</p><pre><code>function unique(arr) {  var ret = [];  var len = arr.length;  var tmp = new Map();  for(var i=0; i&lt;len; i++){    if(!tmp.get(arr[i])){      tmp.set(arr[i], 1);      ret.push(arr[i]);    }  }  return ret;}</code></pre><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>既然都用到了ES2015，数组这件事情不能再简单一点么？当然可以。</p><p>除了Map以外，ES2015还引入了一种叫作Set的数据类型。顾名思义，Set就是集合的意思，它不允许重复元素出现，这一点和数学中对集合的定义还是比较像的。</p><pre><code>var s = new Set();s.add(1);s.add(&apos;1&apos;);s.add(null);s.add(undefined);s.add(NaN);s.add(true);s.add([]);s.add({});</code></pre><p>如果你重复添加同一个元素的话，Set中只会存在一个。包括NaN也是这样。于是我们想到，这么好的特性，要是能和数组互相转换，不就可以去重了吗？</p><pre><code>function unique(arr){    var set = new Set(arr);    return Array.from(set);}</code></pre><p>我们讨论了这么久的事情，居然两行代码搞定了，简直不可思议。</p><p>然而，不要只顾着高兴了。有一句话是这么说的“不要因为走得太远而忘了为什么出发”。我们为什么要为数组去重呢？因为我们想得到不重复的元素列表。而既然已经有Set了，我们为什么还要舍近求远，使用数组呢？是不是在需要去重的情况下，直接使用Set就解决问题了？这个问题值得思考。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><pre><code>var arr = [1,1,&apos;1&apos;,&apos;1&apos;,0,0,&apos;0&apos;,&apos;0&apos;,undefined,undefined,null,null,NaN,NaN,{},{},[],[],/a/,/a/]console.log(unique(arr));</code></pre><blockquote><p>测试中没有定义对象的比较方法，因此默认情况下，对象不去重是正确的结果，去重是不正确的结果。</p></blockquote><img src="/recallwolf.github.io/2019/01/09/js进行数组去重/unique.png">]]></content>
    
    <summary type="html">
    
      实现数组去重的几种方式
    
    </summary>
    
      <category term="JavaScript" scheme="https://recallwolf.github.io/recallwolf.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/JavaScript/"/>
    
      <category term="转载" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Class的继承实现</title>
    <link href="https://recallwolf.github.io/recallwolf.github.io/2018/12/11/Class%E7%9A%84%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0/"/>
    <id>https://recallwolf.github.io/recallwolf.github.io/2018/12/11/Class的继承实现/</id>
    <published>2018-12-11T15:40:18.000Z</published>
    <updated>2020-03-30T15:40:31.384Z</updated>
    
    <content type="html"><![CDATA[<p>ES6新增的“类”与构造函数息息相关，同样的“类”的继承与原型链也存在着紧密的联系。可以参考之前写过一篇关于<a href="/2018/04/10/js的原型链/">原型链</a>的博客。</p><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p><code>class</code>是ES6语法可以把他看做构造函数的语法糖</p><pre><code>class Point {  constructor(x, y) {    this.x = x;    this.y = y;  }  toString() {    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;  }}</code></pre><p>ES5的构造函数改写</p><pre><code>function Point(x, y) {  this.x = x;  this.y = y;}Point.prototype.toString = function () {  return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;};var p = new Point(1, 2);</code></pre><p>可以看出构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。类的所有方法都定义在类的<code>prototype</code>属性上面。</p><pre><code>class Point {  constructor() {    // ...  }  toString() {    // ...  }  toValue() {    // ...  }}// 等同于Point.prototype = {  constructor() {},  toString() {},  toValue() {},};</code></pre><p>在类的实例上面调用方法，其实就是调用原型上的方法。</p><pre><code>class B {}let b = new B();b.constructor === B.prototype.constructor // true</code></pre><p>上面代码中，b是B类的实例，它的constructor方法就是B类原型的<code>constructor</code>方法。</p><p>同样的实例对象的<code>__proto__</code>仍然是指向类的<code>prototype</code></p><pre><code>class B {}let b = new B();b.__proto__ === B.prototype //true</code></pre><h4 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h4><p>Class的本质是构造函数所以继承也是通过原型链的形式，写法上Class可以通过<code>extends</code>关键字实现继承</p><pre><code>class A {}class B extends A {}</code></pre><p>上面代码定义了一个B类，该类通过extends关键字，继承了A类的所有属性和方法。</p><p>由于构造函数同时有<code>prototype</code>属性和<code>__proto__</code>属性，所以“类”也会有两个属性。</p><p>对于“类”来说：  </p><p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p><p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p><pre><code>class A {}class B extends A {}B.__proto__ === A  //trueB.prototype.__proto__ === A.prototype  //true</code></pre><p>以前说过构造函数的<code>__proto__</code>是指向<code>Fucntion.prototype</code>，<code>prototype.__proto__</code>是指向<code>Object.prototype</code>的，对于类A是这样的，对于类B要继承A则要重新指向。</p><p>可以通过<code>Object.setPrototypeOf</code>函数来重指定</p><pre><code>Object.setPrototypeOf = function (obj, proto) {  obj.__proto__ = proto;  return obj;}</code></pre><p>所以<code>extends</code>本质上也是语法糖</p><pre><code>class A {}class B {}// B 的实例继承 A 的实例Object.setPrototypeOf(B.prototype, A.prototype);// B 继承 A 的静态属性Object.setPrototypeOf(B, A);const b = new B();</code></pre><p>同样用ES5构造函数来模拟继承</p><pre><code>function A() {}function B() {}// B 的实例继承 A 的实例Object.setPrototypeOf(B.prototype, A.prototype);// B 继承 A 的静态属性Object.setPrototypeOf(B, A);const b = new B();</code></pre><p>这样继承关系就变成了</p><pre><code>b.__proto__ === B.prototype  //trueb.constructor === B.prototype.constructor //trueB.prototype.__proto__ === A.prototype  //trueB.__proto__ === A  //trueA.prototype.__proto__ === Object.prototype  //trueA.__proto__ === Function.prototype  //true</code></pre><p>要注意的一点是用ES5构造函数来模拟的时候，所有方法都定义在构造函数的prototype属性上面。</p>]]></content>
    
    <summary type="html">
    
      Class与构造函数
    
    </summary>
    
      <category term="JavaScript" scheme="https://recallwolf.github.io/recallwolf.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>JS闭包</title>
    <link href="https://recallwolf.github.io/recallwolf.github.io/2018/12/07/js%E9%97%AD%E5%8C%85/"/>
    <id>https://recallwolf.github.io/recallwolf.github.io/2018/12/07/js闭包/</id>
    <published>2018-12-07T14:26:48.000Z</published>
    <updated>2020-03-30T15:40:31.411Z</updated>
    
    <content type="html"><![CDATA[<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>词法作用域中使用的域，是变量在代码中声明的位置所决定的。嵌套的函数可以访问在其外部声明的变量。</p><pre><code>var a = 100;function init() {  var b = 101;  console.log(&quot;init a:&quot; + a);  function display() {    console.log(&quot;display a:&quot; + a);    console.log(&quot;display b:&quot; + b);  }    display();}init();</code></pre><p>运行结果：</p><pre><code>init a:100display a:100display b:101</code></pre><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包能够读取其他函数内部变量。允许将函数与其所操作的某些数据（环境）关联起来。</p><p>举个列子</p><pre><code>function add(a) {  return function(b) {    a = a + b    console.log(a)  }}var add3 = add(100);var add10 = add(110);add3(3);  //103add10(10);  //120</code></pre><p>add3和add10都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在add3的环境中，a为3。而在add10中，a则为10。</p><p>闭包可以使变量的值始终保持在内存中。</p><pre><code>function init() {  var a = 1;  return function() {    a += 1;    console.log(a);  }}var func = init();func();  //2func();  //3func();  //4</code></pre><p>a并没有在func调用完成后销毁，而是一直保存在内存中。init是匿名函数的父级，匿名函数被赋值给全局变量，会一直存在于内存中。所以init函数也会存在于内存之中。</p><p>大量的使用闭包会占用大量的内存，可能会导致内存泄漏，所以在退出函数之前删除局部变量。</p><pre><code>function init() {  var a = 1;  return {    add: function() {      a += 1;      console.log(a);    },    clear: function() {      a = undefined;    }  } }var func = init();func.add();  //2func.clear(); func.add(); //NaN</code></pre><p>要避免大量的使用闭包，在模拟私有方法的时候可以考虑用let关键词。</p>]]></content>
    
    <summary type="html">
    
      有关JS闭包
    
    </summary>
    
      <category term="JavaScript" scheme="https://recallwolf.github.io/recallwolf.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs和树莓派小车</title>
    <link href="https://recallwolf.github.io/recallwolf.github.io/2018/12/03/nodejs%E5%92%8C%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B0%8F%E8%BD%A6/"/>
    <id>https://recallwolf.github.io/recallwolf.github.io/2018/12/03/nodejs和树莓派小车/</id>
    <published>2018-12-03T06:31:46.000Z</published>
    <updated>2020-03-30T15:40:31.412Z</updated>
    
    <content type="html"><![CDATA[<p>简略的说一下树莓派小车的制作过程</p><p>所需材料：  </p><blockquote><p> 1.树莓派3b+<br>  2.l298n电机驱动模块<br>  3.3.3v直流电机<br>  4.dht11温湿度传感器<br>  5.sg90舵机</p></blockquote><h4 id="基本接线图"><a href="#基本接线图" class="headerlink" title="基本接线图"></a>基本接线图</h4><p><img src="http://ww1.sinaimg.cn/large/616b30bdgy1g0ggmf6bzej21f01v6awl.jpg" alt="sketch.jpg"> </p><h4 id="小车代码"><a href="#小车代码" class="headerlink" title="小车代码"></a>小车代码</h4><p>一开始采用的是rpio库但是pwm的问题一直没解决<br>提了个issue <a href="https://github.com/jperkin/node-rpio/issues/80" target="_blank" rel="noopener">https://github.com/jperkin/node-rpio/issues/80</a></p><p>之后采用了johnny-five库， raspi-io库。<br>由于JavaScript控制微秒级不精准所以采用了第三方库node-dht-sensor调用c++来控制传感器，之后通过websocket传递温湿度</p><p>摄像头部分 用ffmpeg流传输到websocket转发到http上</p><p>所需环境： </p><blockquote><p> 1.os: raspbian<br>  2.nodejs<br>  3.ffmpeg</p></blockquote><p>具体api文档：  </p><blockquote><p><a href="http://johnny-five.io/api/" target="_blank" rel="noopener">Johnny-Five</a><br><a href="https://github.com/nebrius/raspi-io" target="_blank" rel="noopener">raspi-io</a><br><a href="https://github.com/momenso/node-dht-sensor" target="_blank" rel="noopener">node-dht-sensor</a><br><a href="https://github.com/phoboslab/jsmpeg" target="_blank" rel="noopener">JSMpeg</a></p></blockquote><pre><code>var express = require(&apos;express&apos;);var app = express();var path = require(&apos;path&apos;);var http = require(&apos;http&apos;).Server(app);var five = require(&apos;johnny-five&apos;);var Raspi = require(&apos;raspi-io&apos;);var sensor = require(&apos;node-dht-sensor&apos;);var ws = require(&apos;socket.io&apos;)(http);app.use(express.static(path.join(__dirname, &apos;public&apos;)));var board = new five.Board({  io: new Raspi()});function dht11() {  return sensor.read(11, 26)}board.on(&apos;ready&apos;, () =&gt; {  var io23 = new five.Pin({pin:23,mode:4}); //pwm  var io0 = new five.Pin({pin:0,mode:1}); //board_11 left back  var io1 = new five.Pin({pin:1,mode:1}); //board_12 left push  var io2 = new five.Pin({pin:2,mode:1}); //board_13 right push  var io3 = new five.Pin({pin:3,mode:1}); //board_15 right back  var angle = 90;  var servo = new five.Servo({pin:23,startAt:angle});  function set_low(){    io0.low();    io1.low();    io2.low();    io3.low();  };  set_low(); //set default  ws.on(&apos;connection&apos;,function(socket) {    setInterval(() =&gt; {      ws.emit(&apos;sensor&apos;, dht11());    }, 15000);  });  app.get(&apos;/&apos;, function(req, res){    res.render(&apos;index&apos;);  });  app.post(&apos;/w&apos;, function(req, res){    res.send(&apos;w&apos;);    io2.high();    io1.high();  });  app.post(&apos;/ws&apos;, function(req, res){    console.log(&apos;done&apos;);    res.send(&apos;ws&apos;);    io2.high();    io1.high();    setTimeout(() =&gt; {      set_low();    }, 800);  });  app.post(&apos;/l&apos;, function(req, res){    res.send(&apos;l&apos;);    io0.high();    io2.high();  });  app.post(&apos;/ls&apos;, function(req, res){    res.send(&apos;ls&apos;);    io0.high();    io2.high();    setTimeout(() =&gt; {      set_low();    }, 600);  });  app.post(&apos;/r&apos;, function(req, res){    res.send(&apos;r&apos;);    io1.high();    io3.high();  });  app.post(&apos;/rs&apos;, function(req, res){    res.send(&apos;rs&apos;);    io1.high();    io3.high();    setTimeout(() =&gt; {      set_low();    }, 600);  });  app.post(&apos;/b&apos;, function(req, res){     res.send(&apos;b&apos;);    io0.high();    io3.high();  });  app.post(&apos;/bs&apos;, function(req, res){     res.send(&apos;bs&apos;);    io0.high();    io3.high();    setTimeout(() =&gt; {      set_low();    }, 800);  });  app.post(&apos;/stop&apos;, function(req, res){    res.send(&apos;stop&apos;);    set_low();  });  app.post(&apos;/cl&apos;, function(req, res){     res.send(&apos;cl&apos;);    if (angle &gt;= 0 &amp;&amp; angle &lt;= 180) {      angle = angle - 45;      servo.to(angle);    }  });  app.post(&apos;/cr&apos;, function(req, res){     res.send(&apos;cr&apos;);    if (angle &gt;= 0 &amp;&amp; angle &lt;= 180) {      angle = angle + 45;      servo.to(angle);    }  });  app.post(&apos;/creset&apos;, function(req, res){     res.send(&apos;creset&apos;);    angle = 90;    servo.to(angle);  });});http.listen(3000, function(){  console.log(&apos;listening on *:3000&apos;);});</code></pre><p>可以把这些功能封装成一个对象 可能可读性更高</p><p>同时要启动ffmpeg和ws服务器</p><p>前端显示：<br><img src="/recallwolf.github.io/2018/12/03/nodejs和树莓派小车/index.png"> </p><h4 id="语音控制代码"><a href="#语音控制代码" class="headerlink" title="语音控制代码"></a>语音控制代码</h4><img src="/recallwolf.github.io/2018/12/03/nodejs和树莓派小车/pi0.jpg"> <p>之前用了respeaker的2mic的麦克风阵列 原来的的树莓派3b，没有足够的io接口，所以用raspberrypi zero来做语音终端向3b发送控制指令。</p><p>所需环境</p><blockquote><p> 1.os: raspbian<br>  2.nodejs<br>  3.arecord</p></blockquote><p>文档：  </p><blockquote><p><a href="http://wiki.seeedstudio.com/cn/ReSpeaker_2_Mics_Pi_HAT/#2" target="_blank" rel="noopener">respeaker文档</a></p></blockquote><p>大致流程：<br><strong>安装好respeaker驱动(respeaker文档) =&gt; arecord录音 =&gt; 调用百度语音识别api，上传百度服务器 =&gt; 拿到识别结果 向3b上的http服务器发送消息</strong></p><pre><code>var fs = require (&apos;fs&apos;);var exec = require(&apos;child_process&apos;).exec; var axios = require(&apos;axios&apos;);function get_token() {  var url = &apos;https://aip.baidubce.com/oauth/2.0/token?&apos;  return axios.get(url, {    params: {      grant_type: &apos;client_credentials&apos;,      client_id: &apos;Your ID&apos;,      client_secret: &apos;Your Secret&apos;    }  }).then((response) =&gt; {    return Promise.resolve(response.data.access_token)  })  .catch((error) =&gt; {    console.log(error);  });}function get_text(token, data) {  var data = fs.readFileSync(&apos;demo.pcm&apos;);  return axios({    url: `http://vop.baidu.com/server_api?cuid=1E-30-7E-09-21-FD&amp;token=${token}`,    method: &apos;post&apos;,    data: data,    headers: {      &apos;Content-Type&apos;: &apos;audio/pcm;rate=16000&apos;    }  }).then(function(response) {    console.log(response.data)    return Promise.resolve(response.data.result[0]);  }).catch(function (error) {    console.log(error);  });}function forward() {  axios.post(&apos;http://192.168.1.xx:3000/ws&apos;, {});}function back() {  axios.post(&apos;http://192.168.1.xx:3000/bs&apos;, {});}function left() {  axios.post(&apos;http://192.168.1.xx:3000/ls&apos;, {});}function right() {  axios.post(&apos;http://192.168.1.xx:3000/rs&apos;, {});}function record() {  var cmdStr = &apos;arecord -d 3 -c 1 -f cd -r 8000 -Dhw:1 /home/voice/demo.pcm&apos;;  console.log(&apos;----------------begin recording----------------&apos;);  return new Promise((resolve,reject) =&gt; {    exec(cmdStr, function(err, stdout, stderr) {      if (err) {        reject(err);      }      else {        resolve();        console.log(&apos;----------------end recording------------------&apos;);      }    });  });}setInterval(() =&gt; {  record()  .then(get_token)  .then(get_text)  .then(function(text) {    console.log(text);    if(text === &apos;前进，&apos;) {      forward();    }    else if(text === &apos;后退，&apos;) {      back();    }    else if(text === &apos;左转，&apos;) {      left();    }    else if(text === &apos;右转，&apos;) {      right();    }  });}, 4500);</code></pre><p>终端如图：<br><img src="/recallwolf.github.io/2018/12/03/nodejs和树莓派小车/terminal.png">  </p><p><img src="http://ww1.sinaimg.cn/large/616b30bdgy1g0gghrppa2j238w2eo4qt.jpg" alt="car"></p>]]></content>
    
    <summary type="html">
    
      nodejs驱动树莓派
    
    </summary>
    
      <category term="RaspberryPi" scheme="https://recallwolf.github.io/recallwolf.github.io/categories/RaspberryPi/"/>
    
    
      <category term="RaspberryPi" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/RaspberryPi/"/>
    
      <category term="Nodejs" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>JS中异步，同步，回调函数和Promise</title>
    <link href="https://recallwolf.github.io/recallwolf.github.io/2018/12/01/js%E4%B8%AD%E5%BC%82%E6%AD%A5%EF%BC%8C%E5%90%8C%E6%AD%A5%EF%BC%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%92%8CPromise/"/>
    <id>https://recallwolf.github.io/recallwolf.github.io/2018/12/01/js中异步，同步，回调函数和Promise/</id>
    <published>2018-12-01T04:05:16.000Z</published>
    <updated>2020-03-30T15:40:31.386Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-线程，同步，异步和回调函数"><a href="#1-线程，同步，异步和回调函数" class="headerlink" title="1.线程，同步，异步和回调函数"></a>1.线程，同步，异步和回调函数</h3><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><blockquote><p>JS单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个,即主线程。<br>实际上还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外。</p></blockquote><p><strong>Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。</strong></p><p><strong>并且一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都有一个为了处理这个消息相关联的函数。</strong></p><h4 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h4><p>1.函数调用形成了一个栈帧</p><pre><code>function foo(b) {  var a = 10;  return a + b + 11;}function bar(x) {  var y = 3;  return foo(x * y);}console.log(bar(7));  </code></pre><blockquote><p>当调用bar时，创建了第一个帧 ，帧中包含了bar的参数和局部变量。当bar调用foo时，第二个帧就被创建，并被压到第一个帧之上，帧中包含了foo的参数和局部变量。当foo返回时，最上层的帧就被弹出栈（剩下bar函数的调用帧 ）。当bar返回的时候，栈就空了。</p></blockquote><p>2.消息队列  </p><blockquote><p>在事件循环期间的某个时刻，运行时总是从最先进入队列的一个消息开始处理队列中的消息。正因如此，这个消息就会被移出队列，并将其作为输入参数调用与之关联的函数。为了使用这个函数，调用一个函数总是会为其创造一个新的栈帧，一如既往。</p></blockquote><p><strong>当异步线程执行完并且有了结果，会往消息队列推送该结果。</strong><br><strong>当主线程执行完调用栈里的任务，即调用栈为空时，会读取消息队列,并将其作为输入参数调用与之关联的函数。即添加到可执行栈中。</strong></p><p>以上机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环。</p><img src="/recallwolf.github.io/2018/12/01/js中异步，同步，回调函数和Promise/1.png"><p>剩下的概念就很好理解了：<br>同步：如果在函数返回结果的时候，调用者能够拿到预期的结果，即同步。</p><p>异步：如果在函数返回的时候，调用者还不能购得到预期结果，而是将来通过一定的手段得到（例如回调函数），这就是异步。</p><p>回调函数：如上文说道，每一个消息都有一个为了处理这个消息相关联的函数。该函数即为回调函数。</p><blockquote><p>主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息，并执行它。到此为止，就完成了工作线程对主线程的通知，回调函数也就得到了执行。</p></blockquote><img src="/recallwolf.github.io/2018/12/01/js中异步，同步，回调函数和Promise/2.png"><pre><code>console.log(&quot;a&quot;);setTimeout(function() {  console.log(&quot;b&quot;);}, 1000);setTimeout(function() {  console.log(&quot;c&quot;);}, 0);console.log(&quot;d&quot;);</code></pre><p>以上代码执行结果是a d c b</p><h3 id="2-Promise与回调地狱"><a href="#2-Promise与回调地狱" class="headerlink" title="2.Promise与回调地狱"></a>2.Promise与回调地狱</h3><h4 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h4><pre><code>listen( &quot;click&quot;, function handler(evt){  setTimeout( function request(){    ajax( &quot;http://some.url.1&quot;, function response(text){      if (text == &quot;hello&quot;) {        handler();      }      else if (text == &quot;world&quot;) {        request();      }    } );  }, 500) ;} );</code></pre><p>当多个回调函数嵌套就构成了回调地狱。除了缩进产生的横向扩展导致代码的阅读难度，此外还有执行顺序上的问题。<br>上面例子的执行顺序 <strong>监听click事件 =&gt; setTimeout =&gt; ajax =&gt; if判断</strong>，是直观逻辑上的顺序，但是在真实的异步JS程序中，经常会有很多噪音把事情搞乱。</p><p>比如</p><pre><code>doA( function(){  doB();  doC( function(){    doD();  } )  doE();} );doF();</code></pre><p>这段代码执行顺序： <strong>doA =&gt; doF =&gt; doB =&gt; doC =&gt; doE =&gt; doE =&gt; doD</strong><br>这很不符合直观上的逻辑</p><p>当这样的回调嵌套出现很多的时候，代码可读性大大降低。</p><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise就是为了解决回调地狱而产生的，Promise 本质上是一个绑定了回调的对象，而不是将回调传进函数内部。</p><p>Promise 对象有以下两个特点： </p><blockquote><p>（1）对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</p></blockquote><blockquote><p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p></blockquote><p>Promise基本用法</p><pre><code>const promise = new Promise(function(resolve, reject) {  // ... some code  if (/* 异步操作成功 */){    resolve(value);  } else {    reject(error);  }});</code></pre><p>举个例子</p><pre><code>setTimeout(function() {    console.log(&quot;log1&quot;);    setTimeout(function() {        console.log(&quot;log2&quot;);        setTimeout(function() {            console.log(&quot;log3&quot;);        }, 3000);    }, 2000); }, 1000);</code></pre><p>经过Promise封装后</p><pre><code>function firtTimeout() {  return new Promise(function(resolve, reject) {    setTimeout(function() {      resolve(&quot;log1&quot;);    }, 1000);  })}function secondTimeout(result) {  console.log(result);  return new Promise(function(resolve, reject) {    setTimeout(function() {      (&quot;log2&quot;);    }, 2000);  })}function ThirdTimeout(result) {  console.log(result);  return new Promise(function(resolve, reject) {    setTimeout(function() {      resolve(&quot;log3&quot;);    }, 3000);  })}firtTimeout().then(secondTimeout).then(ThirdTimeout).then(function(result) {  console.log(result)})</code></pre><blockquote><p>参考资料 ：<br><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">阮一峰《ECMAScript6入门》</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises" target="_blank" rel="noopener">MDN web docs 使用Promises</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener">MDN web docs 并发模型与事件循环</a><br><a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/async%20%26%20performance/README.md" target="_blank" rel="noopener">getify/You-Dont-Know-JS</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Event Loop, 异步
    
    </summary>
    
      <category term="JavaScript" scheme="https://recallwolf.github.io/recallwolf.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>常用css技巧</title>
    <link href="https://recallwolf.github.io/recallwolf.github.io/2018/09/18/%E5%B8%B8%E7%94%A8css%E5%B8%83%E5%B1%80/"/>
    <id>https://recallwolf.github.io/recallwolf.github.io/2018/09/18/常用css布局/</id>
    <published>2018-09-18T09:01:27.000Z</published>
    <updated>2020-03-30T15:40:31.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="css创建纯三角"><a href="#css创建纯三角" class="headerlink" title="css创建纯三角"></a>css创建纯三角</h3><pre><code>#demo {    width: 0;    height: 0;    border-width: 20px;    border-style: solid;    border-color: transparent transparent red transparent;}</code></pre><p>结果： <img src="/recallwolf.github.io/2018/09/18/常用css布局/triangle.png"></p><h3 id="css水平居中"><a href="#css水平居中" class="headerlink" title="css水平居中"></a>css水平居中</h3><h4 id="1-设置宽度-添加margin-0-auto属性"><a href="#1-设置宽度-添加margin-0-auto属性" class="headerlink" title="1.设置宽度 添加margin: 0 auto属性"></a>1.设置宽度 添加margin: 0 auto属性</h4><pre><code>#demo {    width: 50px;    height: 50px;    margin: 0 auto;    background-color: red;}</code></pre><h4 id="2-浮动元素居中"><a href="#2-浮动元素居中" class="headerlink" title="2.浮动元素居中"></a>2.浮动元素居中</h4><pre><code>#demo {    width: 60px;    height: 50px;    margin: -25px 0 0 -30px;    position: relative;    background-color: red;    left: 50%;    right: 50%;}</code></pre><h4 id="3-绝对定位居中"><a href="#3-绝对定位居中" class="headerlink" title="3.绝对定位居中"></a>3.绝对定位居中</h4><pre><code>#demo {    position: absoulte;    width: 50px;    height: 50px;    background-color: red;    margin: 0 auto;    top: 0;    left: 0;    bottom: 0;    right: 0; }</code></pre><h4 id="4-flex弹性盒子"><a href="#4-flex弹性盒子" class="headerlink" title="4.flex弹性盒子"></a>4.flex弹性盒子</h4><pre><code>.container {    display: flex;    width: 70px;    height: 70px;    border-style: solid;    justify-content: center; /*水平居中*/}.demo {    width: 30px;    height: 30px;    background-color: red;}</code></pre><h3 id="css垂直居中"><a href="#css垂直居中" class="headerlink" title="css垂直居中"></a>css垂直居中</h3><h4 id="1-单行文本-line-height设置和height值相等"><a href="#1-单行文本-line-height设置和height值相等" class="headerlink" title="1.单行文本 line-height设置和height值相等"></a>1.单行文本 line-height设置和height值相等</h4><h4 id="2-已知高度块级子元素-绝对定位-负边距"><a href="#2-已知高度块级子元素-绝对定位-负边距" class="headerlink" title="2.已知高度块级子元素 绝对定位+负边距"></a>2.已知高度块级子元素 绝对定位+负边距</h4><pre><code>.container {    width: 60px;    position: relative;    height: 100px;    border-style: solid;}.demo {    width: 60px;    height: 50px;    position: absolute;    top: 50%;    margin-top: -25px;    background-color: red;}</code></pre><h4 id="3-未知高度的块级子元素居中-模拟表格布局"><a href="#3-未知高度的块级子元素居中-模拟表格布局" class="headerlink" title="3.未知高度的块级子元素居中 模拟表格布局"></a>3.未知高度的块级子元素居中 模拟表格布局</h4><p>   (IE6,7不兼容 父级overflow: hidden无效)</p><pre><code>.container {    display: table;    border-style: solid;    width: 50px;    height: 50px;}.demo {    display: table-cell;    vertical-align: middle;}.cell {    height: 20px;    background-color: red;}</code></pre><h4 id="4-flex弹性盒子-1"><a href="#4-flex弹性盒子-1" class="headerlink" title="4.flex弹性盒子"></a>4.flex弹性盒子</h4><pre><code>.container {    display: flex;    width: 70px;    height: 70px;    border-style: solid;    justify-content: center; /*水平居中*/    align-items: center; /*垂直居中*/}.demo {    width: 30px;    height: 30px;    background-color: red;}</code></pre><h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><p>三列布局 中间主题内容前置，宽度自适应<br>两边内容定宽<br>利用相对定位，浮动，负边距布局</p><p>css部分</p><pre><code>&lt;style&gt;    .container {        padding-left: 190px;        padding-right: 190px;    }    .main {        float: left;        min-height: 130px;        width: 100%;        background-color: yellow;    }    .left {        float: left;        width: 190px;        min-height: 130px;        position: relative;        left: -190px;        margin-left: -100%;        background-color: red;    }    .right {        float: left;        width: 190px;        min-height: 130px;        margin-left: -190px;        position: relative;;        right: -190px;        background-color: blue;    }&lt;/style&gt;</code></pre><p>dom结构</p><pre><code>&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>结果：<img src="/recallwolf.github.io/2018/09/18/常用css布局/grail.png"></p><h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><p>对圣杯布局的改进，消除相对定位布局<br>主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。</p><p>css部分</p><pre><code>&lt;style&gt;    .container {        width: 100%;        float: left;    }    .main {        margin-left: 190px;        margin-right: 190px;        min-height: 130px;        background-color: yellow;    }    .left {        float: left;        width: 190px;        min-height: 130px;        margin-left: -100%;        min-height: 130px;        background-color: red;    }    .right {        float: left;        width: 190px;        min-height: 130px;        margin-left: -190px;        min-height: 130px;        background-color: blue;    }&lt;/style&gt;</code></pre><p>dom结构</p><pre><code>&lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</code></pre><p>结果：<img src="/recallwolf.github.io/2018/09/18/常用css布局/wings.png"></p>]]></content>
    
    <summary type="html">
    
      css的一些经典技巧
    
    </summary>
    
      <category term="CSS" scheme="https://recallwolf.github.io/recallwolf.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>vue与react组件对比</title>
    <link href="https://recallwolf.github.io/recallwolf.github.io/2018/08/13/vue%E4%B8%8Ereact%E7%BB%84%E4%BB%B6%E5%AF%B9%E6%AF%94/"/>
    <id>https://recallwolf.github.io/recallwolf.github.io/2018/08/13/vue与react组件对比/</id>
    <published>2018-08-12T16:08:36.000Z</published>
    <updated>2020-03-30T15:40:31.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数据渲染"><a href="#1-数据渲染" class="headerlink" title="1.数据渲染"></a>1.数据渲染</h2><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><p>Vue采用了传统的 html 模板 通过<code>{{}}</code>或者v-text语法来进行数据的渲染<br>对于数组数据 Vue 中使用类似 Smarty 语法的 <code>v-for</code>指令来渲染数组<br>可以使用computed来对需要渲染的数据进行处理</p><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><p>React通过<code>{}</code>将数据嵌套在JSX表达式中<br>对于数组数据 React利用<code>map</code>将数据片段映射成一段 JSX，然后在列表区域中直接引用<code>map</code>后的 JSX 变量来渲染数组数据<br>React处理渲染的数据 需要 render 函数中定义一个新变量，将转换后的值赋给这个变量后 render </p><p><strong>渲染数组 以数组 a 为例</strong><br>Vue</p><pre><code>&lt;p v-for=&quot;num in a&quot;&gt;{{num}}&lt;/p&gt;</code></pre><p>React</p><pre><code>render() {    {a.map((num) =&gt;         &lt;p&gt;{num}&lt;/p&gt;    )}}  </code></pre><h2 id="2-数据更新"><a href="#2-数据更新" class="headerlink" title="2.数据更新"></a>2.数据更新</h2><h3 id="Vue-1"><a href="#Vue-1" class="headerlink" title="Vue"></a>Vue</h3><p>由于Vue和React实现原理不同所以数据更新的方式也不同<br>Vue Hack 了对象的 setter getter<br>赋值操作时可以setter直接获知状态树中的修改位置</p><pre><code>this.age = 18</code></pre><p><strong>Vue 中数据状态的更新是即时的 DOM状态是异步更新的</strong><br>有些时候需要在数据变动 DOM重渲染完做一些操作需要用<code>Vue.nextTick(callback)</code> DOM 更新完成后就会调用</p><h3 id="React-1"><a href="#React-1" class="headerlink" title="React"></a>React</h3><p>React 需要显式 setState 来获知变更的内容触发DOM的重渲染 </p><pre><code>this.setState({ age: 18 })</code></pre><p><strong>React 中 DOM 状态和数据状态都是异步更新的</strong></p><h2 id="3-数据的双向绑定"><a href="#3-数据的双向绑定" class="headerlink" title="3.数据的双向绑定"></a>3.数据的双向绑定</h2><h3 id="Vue-2"><a href="#Vue-2" class="headerlink" title="Vue"></a>Vue</h3><p>Vue提供了<code>v-model</code>语法对 input 数据进行双向绑定 本质上是v-bind绑定事件和v-on监听事件组成的语法糖</p><h3 id="React-2"><a href="#React-2" class="headerlink" title="React"></a>React</h3><p>React语法 进行数据绑定 onChange事件进行监听数据变化</p><h2 id="4-事件传递"><a href="#4-事件传递" class="headerlink" title="4.事件传递"></a>4.事件传递</h2><h3 id="Vue-3"><a href="#Vue-3" class="headerlink" title="Vue"></a>Vue</h3><blockquote><p>Vue 通过v-on和$emit来实现的。在父组件模板中声明子组件时，通过 <code>v-on:childEventName=&quot;parentHandler&quot;</code> 语法来指定对子组件特定名称事件的 Handler method</p></blockquote><h3 id="React-3"><a href="#React-3" class="headerlink" title="React"></a>React</h3><blockquote><p>React Handler 同样是在父组件中声明，但 Handler 需要以 props 的形式传入子组件，在子组件中触发事件时，以 <code>this.props.parentHandler</code> 形式调用父组件传入的 props 状态</p></blockquote><h2 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="5.生命周期"></a>5.生命周期</h2><h3 id="Vue-4"><a href="#Vue-4" class="headerlink" title="Vue"></a>Vue</h3><img src="/recallwolf.github.io/2018/08/13/vue与react组件对比/vue.png"><blockquote><p>Vue destroyed 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<br>不会清除已有DOM。</p></blockquote><h3 id="React-4"><a href="#React-4" class="headerlink" title="React"></a>React</h3><img src="/recallwolf.github.io/2018/08/13/vue与react组件对比/react.png">  <p>图片来源   (<a href="https://huanghui8030.github.io/react/component.html" target="_blank" rel="noopener">https://huanghui8030.github.io/react/component.html</a>)</p><blockquote><p>React 卸载后不会清除组件的实例 需要在componentWillUnmount生命钩子手动清除  </p></blockquote><p>例如ajax的数据还没获取到就dom就已经不存在，会产生报错</p><blockquote><p>Warning: setState(…): Can only update a mounted or mounting component. This usually means you called setState() on an unmounted component. This is a no-op. Please check the code for the Timer component.</p></blockquote><p>所以需要在 componentWillUnmount() 手动清除</p><pre><code>componentWillUnmount(){    this.setState=()=&gt;{};}</code></pre>]]></content>
    
    <summary type="html">
    
      vue与react数据绑定,DOM渲染,生命周期之间的对比
    
    </summary>
    
      <category term="JavaScript" scheme="https://recallwolf.github.io/recallwolf.github.io/categories/JavaScript/"/>
    
    
      <category term="vue" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/vue/"/>
    
      <category term="react" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>vue结合express后台开发</title>
    <link href="https://recallwolf.github.io/recallwolf.github.io/2018/05/04/vue%E7%BB%93%E5%90%88express%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    <id>https://recallwolf.github.io/recallwolf.github.io/2018/05/04/vue结合express后台开发/</id>
    <published>2018-05-04T09:22:29.000Z</published>
    <updated>2020-03-30T15:40:31.469Z</updated>
    
    <content type="html"><![CDATA[<p>最近打算写一个有即时通讯功能的app练手，用到之前使用过的<code>socket.io</code>库，所以需要<code>vue</code>与<code>express</code>同步协调api（一个人开发就不打算前后端分离了，方便即时调控）</p><h3 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h3><p>1.创建webpack模板(需要安装vue-cli)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack demo</span><br></pre></td></tr></table></figure></p><p>2.安装依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd demo</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>3.修改文件结构<br>将<code>src</code>文件夹修改为<code>client</code><br>将<code>webpack.base.conf.js</code>内的<code>src</code>地址修改为<code>client</code></p><p>4.创建服务端(需要安装express-generator)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">express server</span><br><span class="line">cd server</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>5.修改文件结构<br>将 <strong><em>app.js</em></strong> 中<br><code>app.use(express.static(path.join(__dirname, &#39;public&#39;)));</code><br>修改为<br><code>app.use(express.static(path.resolve(__dirname, &#39;../dist&#39;)));</code></p><h3 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd demo</span><br><span class="line">npm run build</span><br><span class="line">cd server</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>访问<code>http://localhost:3000</code></p>]]></content>
    
    <summary type="html">
    
      vue与express协同开发
    
    </summary>
    
      <category term="vue" scheme="https://recallwolf.github.io/recallwolf.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>JS的原型链</title>
    <link href="https://recallwolf.github.io/recallwolf.github.io/2018/04/10/js%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://recallwolf.github.io/recallwolf.github.io/2018/04/10/js的原型链/</id>
    <published>2018-04-10T09:31:44.000Z</published>
    <updated>2018-12-11T14:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript的继承机制比较特殊 使用prototype链来实现继承</p><h4 id="1-proto-prototype-constructor"><a href="#1-proto-prototype-constructor" class="headerlink" title="1. __proto__,  prototype,  constructor"></a>1. <code>__proto__</code>,  <code>prototype</code>,  <code>constructor</code></h4><p>JavaScript有几种方式来生成实例对象</p><h5 id="第一种方式生成实例对象"><a href="#第一种方式生成实例对象" class="headerlink" title="第一种方式生成实例对象"></a><em>第一种方式生成实例对象</em></h5><pre><code>var person = {}person.name = &quot;recallwolf&quot;person.age = 18</code></pre><p><code>console.log(person)</code> ，我们看到如下图</p><img src="/recallwolf.github.io/2018/04/10/js的原型链/选区1.png"><p>除了自身创建的name和age，我们发现还有一个   <code>__proto__</code> 对象。</p><p><code>__proto__</code> 对象是一个指针，指向上一级对象的prototype，这里指向的Object.prototype</p><blockquote><p>关于 <code>Object.prototype</code> 参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype" target="_blank" rel="noopener">MDN web docs</a></p></blockquote><h5 id="第二种方式生成实例对象"><a href="#第二种方式生成实例对象" class="headerlink" title="第二种方式生成实例对象"></a><em>第二种方式生成实例对象</em></h5><pre><code>function Person(name, age){    this.name = name    this.age = age}var f = new Person(&quot;recallwolf&quot;, 18)</code></pre><p><code>Person()</code>就是构造函数，<code>f</code>是生成的实例对象<br>和第一种方式<strong>不一样的地方</strong>在于，在我们声明构造函数的时候，会设置一个 <code>prototype</code> 属性，这个属性包含 <code>prototype</code> 对象。此外仍存在一个   <code>__proto__</code> 对象，该对象一般指向<code>Function.prototype</code>。</p><p>1.如下图所示，<code>prototype</code> 包含一个 <code>constructor</code> 和 <code>__proto__</code></p><img src="/recallwolf.github.io/2018/04/10/js的原型链/选区2.png"><p><code>contructor</code> 可以看到是指向构造函数本身的指针<br><code>__proto__</code> 是一个指向上一级对象prototype的指针，这里也是指向的Object.prototype</p><p>2.如下图所示，<code>__proto__</code>指向<code>Function.prototype</code></p><img src="/recallwolf.github.io/2018/04/10/js的原型链/选区3.png"><p><strong>相同的是</strong>该创建的实例对象和第一种创建实例对象都会有一个 <code>__proto__</code> 对象，都指向上一级 <code>prototype</code> ，该实例对象指向的是 <code>Person.prototype</code>。</p><img src="/recallwolf.github.io/2018/04/10/js的原型链/选区4.png"><p><strong>不同的是</strong>该创建的实例对象存在<code>constructor</code>并且与构造函数<code>prototype</code>中的<code>constructor</code>相等。</p><img src="/recallwolf.github.io/2018/04/10/js的原型链/选区5.png"><p>构造函数、原型和实例的关系如下图所示</p><blockquote><p>图作者：<a href="https://link.jianshu.com/?t=https://segmentfault.com/u/manxisuo" target="_blank" rel="noopener">manxisuo</a></p></blockquote><img src="/recallwolf.github.io/2018/04/10/js的原型链/图1.png"><blockquote><p><code>prototype</code> 对象有什么用可以参考阮一峰老师的博文<a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="noopener">Javascript继承机制的设计思想</a></p></blockquote><h4 id="2-原型链"><a href="#2-原型链" class="headerlink" title="2.原型链"></a>2.原型链</h4><p>我们查看Person对象是否有name属性时,JS引擎做了：<br>1.查看对象本身有没有name属性，没有则下一步<br>2.查看 <code>person.__proto__</code> 对象有没有 name 属性，如果没有，那么浏览器会继续查看 <code>name.__proto__.__proto__</code> ，直到找到name属性或者 <code>__proto__</code> 为null</p><p>这个 <code>__proto__</code> 组成的链子就是原型链</p><p>如下图所示</p><blockquote><p>图作者：<a href="https://link.jianshu.com/?t=https://segmentfault.com/u/manxisuo" target="_blank" rel="noopener">manxisuo</a></p></blockquote><img src="/recallwolf.github.io/2018/04/10/js的原型链/图2.png"><blockquote><p><code>p</code> 指 <code>prototype</code> 属性，<code>[p]</code> 即 <code>__proto__</code> ，<code>[p]</code> 形成的链（虚线部分）就是原型链</p></blockquote><p>值得注意的是：</p><p>1.<code>Object.prototype</code> 是顶级对象，所有对象都继承自它<br>2.<code>Object.prototype.__proto__ === null</code></p>]]></content>
    
    <summary type="html">
    
      __proto__,  prototype,  constructor
    
    </summary>
    
      <category term="JavaScript" scheme="https://recallwolf.github.io/recallwolf.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS的this指向</title>
    <link href="https://recallwolf.github.io/recallwolf.github.io/2018/04/08/js%E7%9A%84this%E6%8C%87%E5%90%91/"/>
    <id>https://recallwolf.github.io/recallwolf.github.io/2018/04/08/js的this指向/</id>
    <published>2018-04-08T04:50:44.000Z</published>
    <updated>2020-03-30T15:40:31.394Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一般情况下 this 不是在函数定义的时候确定指向！而是在函数执行的时候确定，this指向的是调用函数的那个对象</strong></p><h3 id="this指向的几种情况"><a href="#this指向的几种情况" class="headerlink" title="this指向的几种情况"></a>this指向的几种情况</h3><h4 id="1-纯粹函数调用"><a href="#1-纯粹函数调用" class="headerlink" title="1.纯粹函数调用"></a>1.纯粹函数调用</h4><pre><code>function people(){    this.name = &quot;recallwolf&quot;;    var age = 18;    console.log(this); //Window    console.log(this.name); //recallwolf    console.log(this.age); //undefined}people();</code></pre><p>this最终指向的是调用它的对象，这里的函数people实际是被Window对象所调用</p><pre><code>people() === window.people() //true</code></pre><h4 id="2-作为对象方法的调用"><a href="#2-作为对象方法的调用" class="headerlink" title="2.作为对象方法的调用"></a>2.作为对象方法的调用</h4><pre><code>var o = {    name: &quot;recallwolf&quot;,    fn: function(){        console.log(this.name);  //recallwolf    }}o.fn();</code></pre><p>fn是通过o.fn()执行的,这里的this就是指向调用fn的对象，即o</p><h5 id="值得注意的是"><a href="#值得注意的是" class="headerlink" title="值得注意的是"></a>值得注意的是</h5><pre><code>var o = {    a: 10,    b:{        a: 12,        fn: function(){            console.log(this.a); //12        }    }}o.b.fn();</code></pre><p>this的指向并不是o而是b<br><strong>如果一个函数中有this，这个函数被多个对象包含，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象</strong></p><pre><code>var o = {    a: 18,    fn: function(){        var test = function(){            console.log(this.a); //undefined        }        test();    }}o.fn();</code></pre><p><strong>this不是在函数定义的时候确定指向，在函数里面定义的函数也是要看是谁调用的这个函数(方法)this才是谁；在这里并不是o调用fn里面的test函数，实际上是window</strong></p><p><strong>换种说法，如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在JS的严格版中this是undefined</strong></p><pre><code>var o = {        a: 18,        fn: function(){            var self = this;            var test = function(){                console.log(self.a); //18            }            test();        }    }    o.fn();</code></pre><p>要达到预期目标可以把o这个对象用self保存下来</p><h4 id="3-作为构造函数调用"><a href="#3-作为构造函数调用" class="headerlink" title="3.作为构造函数调用"></a>3.作为构造函数调用</h4><pre><code>function Fn(){    this.name = &quot;recallwolf&quot;;}var a = new Fn();console.log(a.name); //recallwolf</code></pre><p>需要注意的是new关键字可以改变this的指向，将这个this指向对象a<br>new关键字创建一个对象实例，这里用变量a创建了一个fn的实例（相当于复制了一份fn到对象a里面)<br>此时new有三个作用：<br><strong>1.在构造函数内部声明一个临时对象this<br>2.在构造函数fn中默认返回这个临时对象this，赋给a<br>3.将临时对象的<em>proto</em>指向fn的prototype</strong></p><pre><code>function Fn(){    this.name = &quot;recallwolf&quot;;    console.log(this); //Window}var a = Fn();console.log(a.name); //Uncaught TypeError: Cannot read property &apos;name&apos; of undefined</code></pre><p>这是因为this指向的是window对象</p><h5 id="如果构造函数有返回值"><a href="#如果构造函数有返回值" class="headerlink" title="如果构造函数有返回值"></a>如果构造函数有返回值</h5><p><strong>如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。</strong></p><pre><code>function Fn(){      this.name = &quot;recallwolf&quot;;      return {};  }var a = new Fn();  console.log(a.name); //undefinedfunction Fn(){      this.name = &quot;recallwolf&quot;;    return 1;}var a = new Fn();  console.log(a.name); //recallwolffunction Fn(){      this.name = &quot;recallwolf&quot;;     return undefined;}var a = new Fn();  console.log(a.name); //recallwolf</code></pre><p>虽然null也是对象，但是在这里this还是指向那个函数的实例,null比较特殊</p><pre><code>function Fn(){      his.name = &quot;recallwolf&quot;;      return null;}var a = new Fn();  console.log(a.name); //recallwolf</code></pre><h4 id="4-apply调用"><a href="#4-apply调用" class="headerlink" title="4.apply调用"></a>4.apply调用</h4><p>apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。<br>apply()的参数为空时，默认调用全局对象。因此，这时的运行结果为0，证明this指的是全局对象。</p><pre><code>var age = 18;function fn(){    console.log(this.age);}var o = {};o.age =  20;o.m = fn;o.m.apply(); //18o.m.apply(o); //20</code></pre><h3 id="es6箭头函数"><a href="#es6箭头函数" class="headerlink" title="es6箭头函数"></a>es6箭头函数</h3><p><strong>箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象</strong></p><pre><code>var o = {    id: 42,    fn: () =&gt; {        console.log(this.id);    }}o.fn(); //undefinedvar o = {    id: 42,    fn: function(){        console.log(this.id);    }}o.fn(); //42</code></pre><p>普通函数this指向调用它的对象 即o<br>箭头函数this即对象o的this 这里是window</p><p>再举一个例子</p><pre><code>var o = {    id: 12,    fn: function(){        var test = function(){            console.log(this.id) //undefined        }        test();    }}o.fn();var o = {    id: 12,    fn: function(){        var test = () =&gt; {            console.log(this.id); //12        }        test();    }}o.fn();</code></pre><p>箭头函数this即函数fn的this 这里为o</p>]]></content>
    
    <summary type="html">
    
      关于JS this指向的总结
    
    </summary>
    
      <category term="JavaScript" scheme="https://recallwolf.github.io/recallwolf.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>数组随机排列</title>
    <link href="https://recallwolf.github.io/recallwolf.github.io/2018/04/02/%E6%95%B0%E7%BB%84%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%88%97/"/>
    <id>https://recallwolf.github.io/recallwolf.github.io/2018/04/02/数组随机排列/</id>
    <published>2018-04-02T11:20:11.000Z</published>
    <updated>2020-03-30T15:40:31.476Z</updated>
    
    <content type="html"><![CDATA[<h3 id="错误示例"><a href="#错误示例" class="headerlink" title="错误示例"></a>错误示例</h3><pre><code>function shuffle(arr){    return arr.sort(function(){        return Math.random() - 0.5;    });}</code></pre><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>假设一个数组为 [0,1,2,3,4,5,6,7,8,9]<br>如果该算法正确，每个数在每个位置的概率相等且为1 / 10 。<br>将数组重复洗牌足够多次，然后将每次的结果在每一位相加，最后对每一位的结果取平均值，这个平均值应该约等于 (0 + 9) / 2 = 4.5，测试次数越多次，每一位上的平均值就都应该越接近于 4.5 。</p><pre><code>var arr = [0,1,2,3,4,5,6,7,8,9];var res = [0,0,0,0,0,0,0,0,0,0];var time = 10000;for(var i = 0; i &lt; time; i++){    var sorted = shuffle(arr.slice(0));    sorted.forEach(function(value,index){        res[index] += value;    });}res = res.map(function(value){    return value / time;});console.log(res);</code></pre><p>在chrome测试这段代码,可以得出结果，发现结果并不随机分布，各个位置的平均值越往后越大，这意味着这种随机算法越大的数字出现在越后面的概率越大。<br>sort随机算法中元素之间的比较次数通常情况下要远小于正常的 n(n-1)/2，也就意味着有一些元素之间根本就没机会相比较（也就没有了随机交换的可能），这些 sort 随机排序的算法自然也不能真正随机。</p><h3 id="经典洗牌算法Fisher－Yates-Shuffle"><a href="#经典洗牌算法Fisher－Yates-Shuffle" class="headerlink" title="经典洗牌算法Fisher－Yates Shuffle"></a>经典洗牌算法Fisher－Yates Shuffle</h3><pre><code>function shuffle(arr){    var len = arr.length;    for(var i = 0; i &lt; len - 1; i++){        var idx = Math.floor(Math.random() * (len - i));        var temp = arr[idx];        arr[idx] = arr[len - i - 1];        arr[len - i -1] = temp;    }    return arr;}</code></pre><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ol><li>选中数组的最后一个元素</li><li>确定挑选随机元素的范围，从数组的第一个元素到上一步选中的元素都属于这一范围</li><li>从中随机挑选一个数</li><li>交换最后一个元素和随机选中的元素的值</li><li>接下来选中数组内倒数第二的元素</li><li>确定挑选随机元素的范围，从数组的第一个元素到上一步选中的元素都属于这一范围，从中随机挑选一个数</li><li>接着交换倒数第二个元素和第6步随机选中的元素的值，完成对倒数第二个元素随机排列的处理。然后是选中倒数第三个元素，重复之前的操作</li></ol><blockquote><p>引用自：<br>    <a href="https://www.kirupa.com/html5/shuffling_array_js.htm" target="_blank" rel="noopener">https://www.kirupa.com/html5/shuffling_array_js.htm</a><br>    <a href="https://www.h5jun.com/post/array-shuffle.html" target="_blank" rel="noopener">https://www.h5jun.com/post/array-shuffle.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      洗牌算法的正确实现
    
    </summary>
    
      <category term="JavaScript" scheme="https://recallwolf.github.io/recallwolf.github.io/categories/JavaScript/"/>
    
    
      <category term="算法" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>网站部署</title>
    <link href="https://recallwolf.github.io/recallwolf.github.io/2018/03/23/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/"/>
    <id>https://recallwolf.github.io/recallwolf.github.io/2018/03/23/网站部署/</id>
    <published>2018-03-23T09:27:03.000Z</published>
    <updated>2020-03-30T15:40:31.478Z</updated>
    
    <content type="html"><![CDATA[<h3 id="部署准备"><a href="#部署准备" class="headerlink" title="部署准备"></a>部署准备</h3><h4 id="连接server"><a href="#连接server" class="headerlink" title="连接server"></a>连接server</h4><p>Windows环境 xshell + winscp<br>Ubuntu环境 ssh + filezilla<br>安装SSH</p><pre><code>sudo apt-get install openssh-server</code></pre><p>安装好后查看SSH是否启动 </p><pre><code>sudo ps -e |grep ssh</code></pre><p>有sshd,说明ssh服务已经启动，如果没有启动，输入”sudo service ssh start“</p><p>连接服务器</p><pre><code>ssh user@host  如：ssh root@192.168.0.111</code></pre><h4 id="Ubuntu-server环境搭建"><a href="#Ubuntu-server环境搭建" class="headerlink" title="Ubuntu server环境搭建"></a>Ubuntu server环境搭建</h4><h5 id="node-js源码安装"><a href="#node-js源码安装" class="headerlink" title="node.js源码安装"></a>node.js源码安装</h5><pre><code>cd /homewget https://nodejs.org/dist/v9.9.0/node-v9.9.0.tar.gztar -xvf node-v9.9.0.tar.gzcd node-v9.9.0./configuresudo make &amp; make install</code></pre><blockquote><p>对于Ubuntu 16.04.1服务器，默认的Python版本是3.5，默认情况下不安装Python 2.7，甚至没有python可执行文件</p></blockquote><p>./configure 会出现报错</p><pre><code>./configure: 4: exec: python: not found</code></pre><p>安装依赖</p><blockquote><p><a href="https://askubuntu.com/questions/101591/how-do-i-install-the-latest-python-2-7-x-or-3-x-on-ubuntu" target="_blank" rel="noopener">https://askubuntu.com/questions/101591/how-do-i-install-the-latest-python-2-7-x-or-3-x-on-ubuntu</a></p></blockquote><pre><code>sudo apt-get install build-essential checkinstallsudo apt-get install libreadline-gplv2-dev libncursesw5-dev libssl-dev libsqlite3-dev tk-dev libgdbm-dev libc6-dev libbz2-dev</code></pre><blockquote><p>确保make、gcc、g++已经安装好，均使用apt-get的方式直接装</p></blockquote><p>安装python</p><pre><code>sudo apt-get install python2.7</code></pre><h5 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h5><pre><code>sudo apt-get install nginx</code></pre><h5 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h5><pre><code>npm install -g hexo-cli</code></pre><h5 id="pm2安装"><a href="#pm2安装" class="headerlink" title="pm2安装"></a>pm2安装</h5><pre><code>npm install -g pm2</code></pre><h5 id="git-amp-github"><a href="#git-amp-github" class="headerlink" title="git &amp; github"></a>git &amp; github</h5><pre><code>sudo apt-get install git</code></pre><blockquote><p>引用廖雪峰git教程</p></blockquote><blockquote><p>自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p></blockquote><blockquote><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件。</p></blockquote><pre><code>cd ~/.sshlsid_rsa          id_rsa.pub      known_hostscat id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDVRgHi3gPdBcQ... youremail@example.com</code></pre><blockquote><p>如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p></blockquote><pre><code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></pre><blockquote><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。<br>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p></blockquote><blockquote><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：<br>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容<br>点“Add Key”，你就应该看到已经添加的Key</p></blockquote><h3 id="网站搭建"><a href="#网站搭建" class="headerlink" title="网站搭建"></a>网站搭建</h3><h4 id="上传网站和博客至服务器"><a href="#上传网站和博客至服务器" class="headerlink" title="上传网站和博客至服务器"></a>上传网站和博客至服务器</h4><p>FTP or github clone</p><pre><code>git clone git@github.com:recallwolf/blog</code></pre><h4 id="安装依赖启动express服务"><a href="#安装依赖启动express服务" class="headerlink" title="安装依赖启动express服务"></a>安装依赖启动express服务</h4><pre><code>npm installpm2 start ./bin/www</code></pre><p>现在已经可以通过服务器外网ip+端口号访问网站了</p><h4 id="hexo博客生成"><a href="#hexo博客生成" class="headerlink" title="hexo博客生成"></a>hexo博客生成</h4><pre><code>cd blognpm installhexo generate</code></pre><p>生成public<br>更新博文上传至github后</p><pre><code>cd bloggit pull git@github.com:recallwolf/blognpm installhexo generate</code></pre><h4 id="nginx端口映射转发流量"><a href="#nginx端口映射转发流量" class="headerlink" title="nginx端口映射转发流量"></a>nginx端口映射转发流量</h4><p>配置文件位于/etc/nginx/sites-available</p><pre><code>server {    listen 80;    server_name www.rwnexus.site;    location / {        proxy_pass http://127.0.0.1:3000; # 端口映射        proxy_http_version 1.1;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection &apos;upgrade&apos;;        proxy_set_header Host $server_name;        proxy_set_header X-Real-IP $remote_addr;        proxy_cache_bypass $http_upgrade;        proxy_ssl_name $server_name;    }    location /blog {        alias /home/blog/public; # 静态博客入口文件目录        index index.html;    }    error_page 500 502 503 504 /50x.html;    location = /50x.html {        root /usr/share/nginx/html;    }}</code></pre><p>重载nginx配置文件</p><pre><code>nginx -s reload</code></pre><p><strong>现在可以使用  <a href="http://www.rwnexus.site" target="_blank" rel="noopener">www.rwnexus.site</a>　访问网站，<a href="http://www.rwnexus.site/blog" target="_blank" rel="noopener">www.rwnexus.site/blog</a>　访问博客</strong></p>]]></content>
    
    <summary type="html">
    
      记录网站部署至Ubuntu的过程
    
    </summary>
    
      <category term="Ubuntu" scheme="https://recallwolf.github.io/recallwolf.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>个人网站2.0的总结</title>
    <link href="https://recallwolf.github.io/recallwolf.github.io/2018/03/23/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>https://recallwolf.github.io/recallwolf.github.io/2018/03/23/个人总结/</id>
    <published>2018-03-22T16:00:00.000Z</published>
    <updated>2020-03-30T15:40:31.470Z</updated>
    
    <content type="html"><![CDATA[<p>从2017年三月份自学前端也已经有一年了，个人网站也已经迭代到2.0版本。折腾了不少东西，不过幸运的是坚持下来了，这也是我除了打游戏以外坚持最久的事。写下这篇文章的目的就是记录这一年的网站开发历程，反思这一段时间学习中的不足，以及对未来学习开发的规划。</p><h3 id="建站初衷"><a href="#建站初衷" class="headerlink" title="建站初衷"></a>建站初衷</h3><p>被动成为互联网消费终端的消费者，这让我感到很难受，我一直希望我自己能为互联网产出而不是消费互联网。（虽然现在的产出很垃圾）<br>偶然接触到前端，对网页开发感到兴趣。<br>希望在互联网上能有一块不被朋友圈，微博等聒噪的环境影响的地方。</p><h4 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h4><p>技术栈：javascript，html5，css3，jquery，ajax，bootstrap<br>博客采用django zinnia blog的开源项目<br>第一次上手开发自己的网站，甚至不知道怎么调试bug，碰到了诸如虚拟环境 Apache Python版本坑。碰到没有GUI的Ubuntu很头大。</p><h4 id="2-0版本"><a href="#2-0版本" class="headerlink" title="2.0版本"></a>2.0版本</h4><p>技术栈：javascript，html5，css3，vue2.0 使用es6语言规范开发<br>博客采用了hexo静态博客开源项目 是一个无数据库博客<br>开始使用es6的模块开发，组件能够复用。vue很容易上手，使用也很舒服。</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>慢慢习惯了Ubuntu的操作，即使没有GUI也能完成一定的需求。<br>跟着mooc网做了几个较大的项目，vue音乐app,和饿了么spa页面。</p><h4 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h4><p>对于开发停留在会用阶段，很多原理性的东西不了解。<br>基础不牢固，表现在css的布局，html5的meta标签，JS的原型，this指向等。<br>做项目时很多时候是按照老师的思路，并没有自己的思考，掌握的不是很扎实。</p><h4 id="未来规划"><a href="#未来规划" class="headerlink" title="未来规划"></a>未来规划</h4><p>接下来的学习不会追一些新的技术，把侧重点放在基础学习中。巩固好JS html css基础。<br>用jQuery和原JS写一写网页常用的特效。<br>初步了解Angular或者React框架。<br>尝试在项目中应用css预处理器。</p><p><strong>静下心，忠于基础。努力成为一名合格前端工程师。</strong></p>]]></content>
    
    <summary type="html">
    
      写下这篇文章的目的就是记录这一年的网站开发历程，反思这一段时间学习中的不足，以及对未来学习开发的规划。
    
    </summary>
    
      <category term="Others" scheme="https://recallwolf.github.io/recallwolf.github.io/categories/Others/"/>
    
    
      <category term="个人网站" scheme="https://recallwolf.github.io/recallwolf.github.io/tags/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
</feed>
